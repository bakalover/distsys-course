# Atomic KV

Вам дана [наивная реализация](kv/node/main.cpp) небольшого KV хранилища с операциями `Set(key, value)` и `Get(key)`:

- Координатор операции `Set(key, value)` выбирает временную метку (`WriteTimestamp`) для записи с помощью локальных часов и синхронно записывает `value` с этой временной меткой (`StampedValue`) на кворум из большинства узлов.


- Координатор операции `Get(key)` собирает версионированные значения для ключа `key` с кворума и выбирает из них значение с максимальной временной меткой.

Такая реализация не гарантирует [линеаризуемость](https://jepsen.io/consistency/models/linearizable).

Ваша задача – доработать протокол репликации и добиться линеаризуемого поведения. 

Для этого:

- Добавьте в операцию чтения фазу записи чтобы гарантировать, что последующие чтения не могут прочитать более старое значение.
- Реализуйте надежную процедуру генерации монотонных меток для записей. 

## Алгоритм Attiya-Bar-Noy-Dolev (ABD)

- [Notes on Theory of Distributed Systems](https://www.cs.yale.edu/homes/aspnes/classes/465/notes.pdf) – Chapter 16 – _Distributed Shared Memory_
- [Лекции Мартинка Клеппмана](https://www.cl.cam.ac.uk/teaching/2021/ConcDisSys/dist-sys-notes.pdf)
- [Оригинальная статья](https://groups.csail.mit.edu/tds/papers/Attiya/TM-423.pdf)

## Генерация временных меток

Координаторы записей должны генерировать для них монотонные временные метки: 

Если запись _W_ завершилась в физическом времени до начала записи _W'_, то временная метка для записи _W'_ должна быть строго больше метки для _W_.

### Настенные часы

В данной вам реализации координатор записи в качестве временной метки использует показания своих локальных часов:

```cpp
WriteTimestamp ChooseWriteTimestamp() const {
  return {whirl::node::rt::WallTimeNow().ToJiffies().Count()};
}

```

Если часы на координаторе записи _W_ спешили, а на координаторе _W'_ – отставали, то порядок этих записей для реплик (порядок на временных метках) будет расходиться с порядком операций в физическом времени (порядок для клиентов), и линеаризуемость будет нарушена.

Реализуйте один из двух надежных способов генерации временных меток:

### Логические часы

Добавьте в `Set` фазу кворумного чтения, и из полученных ответов сгенерируйте свежую временную метку для записи.

Иными словами, замените физические часы на логические.

### TrueTime

Используйте [TrueTime](https://gitlab.com/whirl-framework/whirl-frontend/-/blob/master/whirl/node/time/true_time_service.hpp)

#### TrueTime в Spanner

[Spanner: Google's Globally-Distributed Database](https://research.google/pubs/pub39966/)

TrueTime позволяет узлам-координаторам в Google Spanner генерировать монотонные временные метки для транзакций _локально_, без общения с централизованным Timestamp Oracle-а, т.е. без коммуникации по сети.

## Отказоустойчивость

Ваша реализация должна переживать отказ произвольного меньшинства узлов и рестарты узлов.

## Замечания по реализации

### Роли и сервисы

Каждый узел в алгоритме ABD играет две _роли_:

- _Координатор_ клиентской операции: генерирует временные метки, собирает кворумы, отвечает клиенту.
- _Реплика_: обслуживает команды на запись / чтение от координаторов клиентских операций.

В коде эти роли представлены двумя отдельными RPC-сервисами: `Coordinator` и `Replica` соответственно.

### Контексты

Используйте `await::context::Scope` или `await::context::StopScope` для управления отменой RPC в пределах фазы алгоритма ABD. 


